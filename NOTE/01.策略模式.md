阅读《HeadFirst 设计模式》《Android源码设计模式解析与实战》
写demo代码和注释，围绕模式类型（产生问题，解决问题，总结经验）写笔记

1.策略模式
产生问题：从模拟鸭子应用开始
阿明工作的公司有一个鸭子模拟应用，现在有一个鸭子父类(Duck),这个类中包含了一些鸭子的常见方法
比如quack()、swim()、display()。后来市场竞争激烈，鸭子功能发生的变化,需要添加fly()的方法。
鸭子老爸，有一些儿子：红头鸭，绿头鸭，木头鸭，石头鸭。。。阿明开始想把fly()方法放到Duck类中，但是
沉思片刻后发现一个问题，木头鸭和石头鸭是不能飞的，该怎么办？只要在木头鸭和石头鸭中override,
fly()方法，什么都不写，问题不就解决了，我真是个聪明的小机灵蛋呢，阿明心里默默念叨。问题是鸭子老爸
的儿子还有很多不会飞的，一个一个重写实在麻烦。那么为什么不用继承呢，把fly()方法，放入Flyable中，让
有飞行能力的鸭子实现Flyable接口。可是这样的话，每次都要重写一遍fly方法，代码的复用性太低。

现在问题：对于变化的方法fly(),写在父类Duck中由子类继承重写不好，放到Flyable接口中由需要的鸭子实现，
代码的复用性又很低。

如何解决：

将变化的fly()抽取出来到一个类中，由这个类(FlyWithWings,FlyWithRocket,FlyNoWay)来具体实现fly方法.
这样FlyWithWings就和Duck类没有关系，而且当有一个其他类，比如Bird类，有fly方法的时候，FlyWithWings
就可以被复用。

总结经验
1.设计原则：封装变化
找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。

2.设计原则：针对接口编程，而不是针对实现编程。

针对接口编程的真正意思是：针对超类型编程
针对实现编程
ReadHeadDuck duck =new RedHeadDuck();
duck.fly
针对接口编程
Duck duck=new ReadHeadDuck();
duck.performFly()

3.设计原则：多用组合，少用继承

4.策略模式
定义；策略模式定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法
的客户。

